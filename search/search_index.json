{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PyFoliage's Documentation","text":"<p>PyFoliage is a Python library designed to calculate the green canopy cover of plants in images. It is a spin-off from the Canopeo application and uses the same algorithm to classify green canopy cover.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Calculate the green canopy cover in a single image or a list of images.</li> <li>Apply a mask to classify the green canopy cover in an image.</li> <li>Extract EXIF metadata from images, including date/time and geolocation data.</li> <li>Save the generated mask as a binary image.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>First, install the library using pip:</p> <pre><code>pip install pyfoliage\n</code></pre> <p>Then, you can import PyFoliage in your Python scripts:</p> <pre><code>import pyfoliage\n</code></pre> <p>See the Getting Started Guide for more detailed usage examples.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>For more detailed descriptions of how to use PyFoliage, see the examples. The API Reference contains detailed information about the functions and classes in PyFoliage.</p>"},{"location":"#feedback","title":"Feedback","text":"<p>For making feature requests and reporting errors, please open an issue in the Github repository.</p>"},{"location":"#privacy-and-image-metadata","title":"Privacy and image metadata","text":"<p>PyFoliage retrieves metadata such as image name, image dimensions, timestamp, and geographic coordinates already present in the images. If the images don't contain geographic coordinates, PyFoliage outputs null values. PyFoliage does not collect any private user or image information.</p>"},{"location":"#license","title":"License","text":"<p>PyFoliage is an open-source project under the MIT license. We only request that you acknowledge and properly cite our work.</p>"},{"location":"#green-canopy-cover-methodology","title":"Green canopy cover methodology","text":"<p>Details of the image processing routine are described in:         Patrignani, A. and Ochsner, T.E. (2015), Canopeo: A Powerful New Tool for Measuring Fractional Green Canopy Cover. Agronomy Journal, 107: 2312-2320. https://doi.org/10.2134/agronj15.0150</p>"},{"location":"#external-packages","title":"External packages","text":"<p>This tool wouldn't be possible without the following projects:</p> <ul> <li>Pillow</li> <li>NumPy</li> <li>pandas</li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pyfoliage.pyfoliage.canopy_cover","title":"<code>canopy_cover(images, red_green_max=0.95, blue_green_max=0.95, ExG_min=20, parse_metadata=True, save_mask=False, parallel=False)</code>","text":"<p>Returns a pandas dataframe with the canopy cover values for each image.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str or list</code> <p>Path to the image list of paths or directory can be specified using wildcards (*) in the string. See glob for more information.</p> required <code>red_green_max</code> <code>float</code> <p>Maximum value for the red/green ratio. Defaults to 0.95.</p> <code>0.95</code> <code>blue_green_max</code> <code>float</code> <p>Maximum value for the blue/green ratio. Defaults to 0.95.</p> <code>0.95</code> <code>ExG_min</code> <code>int</code> <p>Minimum value for the ExG index. Defaults to 20.</p> <code>20</code> <code>parse_metadata</code> <code>bool</code> <p>Whether to parse the metadata of the image. Defaults to True.</p> <code>True</code> <code>save_mask</code> <code>bool</code> <p>Whether to save the mask of the image. Defaults to False.</p> <code>False</code> <code>parallel</code> <code>bool</code> <p>Whether to use parallel processing (faster). Please note that this will use all the available cores in your machine, so if you are running other processes, it is recommended to set this to False. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>pd.DataFrame: Pandas dataframe with the canopy cover values for each image.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\PyFoliage\\lib\\site-packages\\pyfoliage\\pyfoliage.py</code> <pre><code>def canopy_cover(images, red_green_max=0.95, blue_green_max=0.95, ExG_min=20, parse_metadata=True, save_mask=False, parallel=False):\n\"\"\"Returns a pandas dataframe with the canopy cover values for each image.\n\n    Args:\n        images (str or list): Path to the image list of paths or directory can be specified using wildcards (*) in the string. See [glob](https://docs.python.org/3/library/glob.html) for more information.\n        red_green_max (float, optional): Maximum value for the red/green ratio. Defaults to 0.95.\n        blue_green_max (float, optional): Maximum value for the blue/green ratio. Defaults to 0.95.\n        ExG_min (int, optional): Minimum value for the ExG index. Defaults to 20.\n        parse_metadata (bool, optional): Whether to parse the metadata of the image. Defaults to True.\n        save_mask (bool, optional): Whether to save the mask of the image. Defaults to False.\n        parallel (bool, optional): Whether to use parallel processing (faster). Please note that this will use all the available cores in your machine, so if you are running other processes, it is recommended to set this to False. Defaults to False.\n\n    Returns:\n        pd.DataFrame: Pandas dataframe with the canopy cover values for each image.\n    \"\"\"\n    # check if is string and is a directory\n    if isinstance(images, str) and \"*\" in images:\n        images = glob.glob(images)\n    elif isinstance(images, str):\n        images = [images]\n\n    args = [(image, red_green_max, blue_green_max, ExG_min, parse_metadata, save_mask) for image in images]\n\n    if parallel:\n        with Pool() as p:\n            canopy_cover_rows = list(tqdm(p.imap(process_image, args), total=len(images), desc=\"Processing images\", unit=\"image\"))\n    else:\n        canopy_cover_rows = list(tqdm(map(process_image, args), total=len(images), desc=\"Processing images\", unit=\"image\"))\n\n    canopy_cover_rows = [row for row in canopy_cover_rows if row is not None]\n    results = pd.DataFrame(canopy_cover_rows)\n    return results\n</code></pre>"},{"location":"reference/#pyfoliage.pyfoliage.cc_image","title":"<code>cc_image(image, red_green_max=0.95, blue_green_max=0.95, ExG_min=20, plot=False)</code>","text":"<p>Returns a binary mask of the image based on the green canopy cover, as described in Patrignani and Ochsner (2015).</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Path to the image.</p> required <code>red_green_max</code> <code>float</code> <p>Maximum value for the red/green ratio. Defaults to 0.95.</p> <code>0.95</code> <code>blue_green_max</code> <code>float</code> <p>Maximum value for the blue/green ratio. Defaults to 0.95.</p> <code>0.95</code> <code>ExG_min</code> <code>int</code> <p>Minimum value for the ExG index. Defaults to 20.</p> <code>20</code> <p>Returns:</p> Type Description <p>np.array: Binary mask of the image.</p> References <p>Patrignani, A. and Ochsner, T.E. (2015), Canopeo: A Powerful New Tool for Measuring Fractional Green Canopy Cover. Agronomy Journal, 107: 2312-2320. https://doi.org/10.2134/agronj15.0150</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\PyFoliage\\lib\\site-packages\\pyfoliage\\pyfoliage.py</code> <pre><code>def cc_image(image, red_green_max=0.95, blue_green_max=0.95, ExG_min=20, plot=False):\n\"\"\"Returns a binary mask of the image based on the green canopy cover, as described in Patrignani and Ochsner (2015).\n\n    Args:\n        image (str): Path to the image.\n        red_green_max (float, optional): Maximum value for the red/green ratio. Defaults to 0.95.\n        blue_green_max (float, optional): Maximum value for the blue/green ratio. Defaults to 0.95.\n        ExG_min (int, optional): Minimum value for the ExG index. Defaults to 20.\n\n    Returns:\n        np.array: Binary mask of the image.\n\n    References:\n        Patrignani, A. and Ochsner, T.E. (2015), Canopeo: A Powerful New Tool for Measuring Fractional Green Canopy Cover. Agronomy Journal, 107: 2312-2320. https://doi.org/10.2134/agronj15.0150\n    \"\"\"\n    # Load the image\n    img = Image.open(image)\n\n    # Convert the image into a numpy array\n    np_img = np.array(img)\n\n    # Split into channels\n    r, g, b = np_img[...,0], np_img[...,1], np_img[...,2]\n\n    # Calculate red to green ratio for each pixel. The result is an m x n array.\n    red_green_ratio = r / (g + 1e-100)\n\n    # Calculate blue to green ratio for each pixel. The result is an m x n array.\n    blue_green_ratio = b / (g + 1e-100)\n\n    # Excess green\n    ExG = 2 * g - r - b\n\n    # Classify pixels\n    bw = np.logical_and(red_green_ratio &lt; red_green_max, blue_green_ratio &lt; blue_green_max, ExG &gt; ExG_min)\n    bw = np.uint8(bw)\n    bw = ndimage.binary_opening(bw, structure=np.ones((10, 10))).astype(int)\n\n    # If plot is True, display the images and print the canopy cover percentage\n    if plot:\n        # Calculate the canopy cover percentage\n        cc_percent = np.sum(bw) / np.size(bw) * 100\n\n        # Create subplots\n        fig, ax = plt.subplots(1, 2, figsize=(10, 5))\n\n        # Plot the original image\n        ax[0].imshow(img)\n        ax[0].set_title('Original Image')\n\n        # Plot the masked image\n        ax[1].imshow(bw, cmap='gray')\n        ax[1].set_title('Masked Image')\n\n        # Set super title with the canopy cover percentage\n        plt.suptitle(f'Canopy cover percentage: {round(cc_percent,1)}%', fontsize=16)\n\n        # Extract EXIF data for footer\n        exif_data = img._getexif()\n        if exif_data is not None:\n            for tag, value in exif_data.items():\n                if tag in ExifTags.TAGS:\n                    # Add footer text with date/time and GPS info if available\n                    if ExifTags.TAGS[tag]=='DateTimeOriginal':\n                        fig.text(0.5, 0.08, f'Date/Time: {value}', ha='center')\n                    if ExifTags.TAGS[tag]=='GPSInfo':\n                        # check if geolocation data is available\n                        lat = __get_decimal_from_dms(value[2], value[1])\n                        lon = __get_decimal_from_dms(value[4], value[3])\n                        fig.text(0.5, 0.04, f'GPS: {lat}, {lon}', ha='center')\n        # filename plot\n        fig.text(0.5, 0.01, image, ha='center', fontsize=6)\n        # Show the plots\n        plt.show()\n\n    return bw\n</code></pre>"},{"location":"example/example/","title":"Example","text":"In\u00a0[7]: Copied! <pre># Import modules\nimport pyfoliage, glob\nimport numpy as np\nimport pandas as pd\n</pre> # Import modules import pyfoliage, glob import numpy as np import pandas as pd   In\u00a0[8]: Copied! <pre># Read images from directory containing wildcard '*'\ntubes = pyfoliage.canopy_cover(\"C:/Users/jperaza/Soil Water Lab Dropbox/KSU Soil Water Lab/Soil Water Lab/Projects data/RAIN/Plots/Images/*/*\", parallel=True)\n</pre> # Read images from directory containing wildcard '*' tubes = pyfoliage.canopy_cover(\"C:/Users/jperaza/Soil Water Lab Dropbox/KSU Soil Water Lab/Soil Water Lab/Projects data/RAIN/Plots/Images/*/*\", parallel=True)  <pre>Processing images: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6622/6622 [18:27&lt;00:00,  5.98image/s]\n</pre> In\u00a0[9]: Copied! <pre># Extract the plot and tube numbers from the file paths with error handling\ndef extract_plot_and_tube_numbers(path):\n    try:\n        parts = path.split('\\\\')[-2].split('_')\n        return parts[0], parts[1]\n    except IndexError:\n        return 'NaN', 'NaN'\n\ntubes['plot_number'], tubes['tube_number'] = zip(*tubes['image'].apply(extract_plot_and_tube_numbers))\n\n# Display the first few rows of the dataframe\ntubes[['image', 'plot_number', 'tube_number']].head()\n</pre> # Extract the plot and tube numbers from the file paths with error handling def extract_plot_and_tube_numbers(path):     try:         parts = path.split('\\\\')[-2].split('_')         return parts[0], parts[1]     except IndexError:         return 'NaN', 'NaN'  tubes['plot_number'], tubes['tube_number'] = zip(*tubes['image'].apply(extract_plot_and_tube_numbers))  # Display the first few rows of the dataframe tubes[['image', 'plot_number', 'tube_number']].head() Out[9]: image plot_number tube_number 0 C:/Users/jperaza/Soil Water Lab Dropbox/KSU So... 101 1 1 C:/Users/jperaza/Soil Water Lab Dropbox/KSU So... 101 1 2 C:/Users/jperaza/Soil Water Lab Dropbox/KSU So... 101 1 3 C:/Users/jperaza/Soil Water Lab Dropbox/KSU So... 101 1 4 C:/Users/jperaza/Soil Water Lab Dropbox/KSU So... 101 1 In\u00a0[10]: Copied! <pre>tubes.to_csv(\"canopy_cover.csv\")\n</pre> tubes.to_csv(\"canopy_cover.csv\") In\u00a0[2]: Copied! <pre>canopy=pd.read_csv(\"canopy_cover.csv\")\n</pre> canopy=pd.read_csv(\"canopy_cover.csv\")  In\u00a0[6]: Copied! <pre>pyfoliage.cc_image(canopy.iloc[667,1], plot=True)\n</pre> pyfoliage.cc_image(canopy.iloc[667,1], plot=True)  Out[6]: <pre>array([[0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       ...,\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0]])</pre> In\u00a0[11]: Copied! <pre>pyfoliage.cc_image(canopy.iloc[657,1], plot=True)\n</pre> pyfoliage.cc_image(canopy.iloc[657,1], plot=True)  Out[11]: <pre>array([[1, 1, 1, ..., 1, 1, 1],\n       [1, 1, 1, ..., 1, 1, 1],\n       [1, 1, 1, ..., 1, 1, 1],\n       ...,\n       [1, 1, 1, ..., 1, 1, 1],\n       [1, 1, 1, ..., 1, 1, 1],\n       [1, 1, 1, ..., 1, 1, 1]])</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"example/example/#test-plotting-functions","title":"Test plotting functions\u00b6","text":""}]}